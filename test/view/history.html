<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="renderer" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <link rel="stylesheet" href="../2dSdk/HG2DMap.min.css">
    <link rel="stylesheet" href="https://cdn.bootcss.com/element-ui/2.12.0/theme-chalk/index.css">
    <style>
        #map{
            border: 1px solid pink;
        }
        .map_tool{
            position: absolute;
            bottom: 60px;
            left: 60px;
            right: 60px;
            height: 40px;
            background-color: rgba(255, 255, 255, .5);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .map_tool i{
            font-size: 18px;
            margin: 0 4px;
            cursor: pointer;
        }
        .time-slide{
            flex: 1;
            padding: 0 30px;
            box-sizing: border-box;
        }
        .el-slider__stop{
            background-color: #ccc;
        }
    </style>
</head>

<body>
    <div id="app">
        <div>

           <el-form  :inline="true"  class="demo-form-inline" @submit.native.prevent>
                <el-form-item label="时间：">
                    <el-date-picker
                      v-model="timeArr"
                      type="datetimerange"
                      range-separator="至"
                      start-placeholder="开始时间"
                      end-placeholder="结束时间">
                    </el-date-picker>
               </el-form-item>
               <el-form-item>
                <el-button type="primary" @click="searchClick()" size="medium">查询</el-button>
                <el-button @click="searchClick(1)" size="medium">重置</el-button>
              </el-form-item>
           </el-form>
                                  

        </div>
        <div :style="{
                'height':mapHeight,
                'width':mapWidth,
                'position':'relative'
            }">
            <div 
            ref="map" 
            id="map" 
            :style="{
                'height':mapHeight,
                'width':mapWidth,
            }">

            </div>
            <div class="map_tool">
                <i class="el-icon-circle-plus-outline" title="速度加倍" @click="changeSpeed(2)"></i>
                <i class="el-icon-remove-outline" title="速度减半" @click="changeSpeed(0.5)"></i>
                <i class="el-icon-refresh" title="原速" @click="changeSpeed(1)"></i>
                {{playParams.speed / 1000}}s
                <div class="time-slide">
                    <el-slider
                      @change="sliderChange"
                      @input="sliderInput"
                       ref="slider"
                      :format-tooltip="formatTooltip"
                      v-model="playParams.currentTime"
                      :show-tooltip="true"
                      :max="rangeMax">
                    </el-slider>
                </div>
                
                <i v-if="!playParams.play" class="el-icon-success" title="播放" @click="play_pause()"></i>
                <i v-else class="el-icon-d-caret" title="暂停" @click="play_pause(1)"></i>
                
                
            </div>
        </div>
        {{playParams.currentTime}}



    </div>

    <script src="../2dSdk/HG2DMap.min.js"></script>
    <script src="https://cdn.bootcss.com/vue/2.6.10/vue.js"></script>
    <script src="https://cdn.bootcss.com/element-ui/2.12.0/index.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js"></script>
    <script>
    Date.prototype.format = function(fmt){
        let o = {
            "M+":this.getMonth() + 1,
            "d+":this.getDate(),
            "h+":this.getHours(),
            "m+":this.getMinutes(),
            "s+":this.getSeconds(),
            "q+":Math.floor((this.getMonth() + 3) / 3),
            "S":this.getMilliseconds()
        }

        if (/(y+)/i.test(fmt)){
            fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length))
        }

        for (var k in o){
            if(Object.hasOwnProperty.call(o,k)){
                if(new RegExp("(" + k + ")", "i").test(fmt)){
                    fmt = fmt.replace(
                        RegExp.$1,(RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))
                    )
                }
            }
        }

        return fmt
    }
    String.prototype.colorRgb = function (opacity) {
      // 16进制颜色值的正则
      var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
      // 把颜色值变成小写
      var color = this.toLowerCase();
      if (reg.test(color)) {
        // 如果只有三位的值，需变成六位，如：#fff => #ffffff
        if (color.length === 4) {
          var colorNew = "#";
          for (var i = 1; i < 4; i += 1) {
            colorNew += color.slice(i, i + 1).concat(color.slice(i, i + 1));
          }
          color = colorNew;
        }
        // 处理六位的颜色值，转为RGB
        var colorChange = [];
        for (var i = 1; i < 7; i += 2) {
          colorChange.push(parseInt("0x" + color.slice(i, i + 2)));
        }
        return "rgba(" + colorChange.join(",") + ',' + (opacity || 1 ) +")";
      } else {
        return color;
      }
    }

    let mixins = {
            methods: {
                //自适应缩放比
                mapAutomaticSetting(map_zoom, x, y, times, extend, map_div) {
                    var obj = {};
                    // 如果缩放比为空
                    if (map_zoom == 0) {
                        var map_x = parseFloat(Math.abs(parseFloat(extend[2]) - parseFloat(extend[0]))); // 得到地图文件的宽
                        var map_y = parseFloat(Math.abs(parseFloat(extend[3]) - parseFloat(extend[0]))); // 得到地图文件的高
                        var div_x = parseFloat($("#" + map_div).width()); // 得到显示地图的div的宽
                        var div_y = parseFloat($("#" + map_div).height()); // 得到显示地图的div的高
                        var max_x = parseFloat(div_x / (map_x * 73)); // 当缩放比为40时，地图1m对应像素值73px,当缩放比加1，对应像素值增加1.5倍。max_x为对应像素值还需要增加或减少多少倍才能等于div的宽度
                        var max_y = parseFloat(div_y / (map_y * 73)); // max_y 同理max_x
                        var zoom_x = Math.log(max_x) / Math.log(1.5); // 求出地图宽的对应像素值需要增加或减少的倍数值,1.5为地图的缩放比系数zoom_factor,详情可参考2dSDK文档
                        var zoom_y = Math.log(max_y) / Math.log(1.5); // 高与宽同理
                        obj.zoom = parseFloat(40 + Math.min(zoom_x, zoom_y)).toFixed(2); // 40加上或减去倍数，就是最合适的缩放比
                    } else {
                        obj.zoom = parseFloat(map_zoom);
                    }
                    // 如果中心视点为空
                    var center_x, center_y, times_drag;
                    if (x == null) {
                        // 以地图文件的坐标系为原点算出地图文件的中心视点的x值
                        center_x = parseFloat(((parseFloat(extend[2]) - parseFloat(extend[0])) / 2 + parseFloat(extend[0])).toFixed(2));
                    } else {
                        center_x = parseFloat(x);
                    }
                    if (y == null) {
                        // 以地图文件的坐标系为原点算出地图文件的中心视点的y值
                        center_y = parseFloat(((parseFloat(extend[3]) - parseFloat(extend[1])) / 2 + parseFloat(extend[1])).toFixed(2));
                    } else {
                        center_y = parseFloat(y);
                    }
                    obj.center = [center_x, center_y];
                    // 如果拖拽倍数为空
                    if (times == null) {
                        // 拖拽倍数设为1
                        times_drag = 1;
                    } else {
                        times_drag = parseFloat(times);
                    }
                    // 计算出限制地图离中心视点拖拽的距离(地图文件宽和高的times_drag倍)的坐标
                    var extent = [center_x - times_drag * Math.abs((parseFloat(extend[2]) - parseFloat(extend[0]))), center_y - times_drag * Math.abs((parseFloat(extend[3]) - parseFloat(extend[1]))), center_x + times_drag * Math.abs((parseFloat(extend[2]) - parseFloat(extend[0]))), center_y + times_drag * Math.abs((parseFloat(extend[3]) - parseFloat(extend[1])))];
                    obj.extent = extent;
                    return obj;
                },
                myTime: function(val, fmt) {
                    var Dates = new Date(parseInt(val));
                    var o = {
                        'M+': Dates.getMonth() + 1,
                        'd+': Dates.getDate(),
                        'h+': Dates.getHours(),
                        'm+': Dates.getMinutes(),
                        's+': Dates.getSeconds(),
                        'q+': Math.floor((Dates.getMonth() + 3) / 3),
                        'S+': Dates.getMilliseconds()
                    }
                    if (/(y+)/.test(fmt)) {
                        fmt = fmt.replace(RegExp.$1, (Dates.getFullYear() + '').substring(4 - RegExp.$1.length))
                    }
                    for (var k in o) {
                        if (o.hasOwnProperty(k)) {
                            if (new RegExp('(' + k + ')').test(fmt)) {
                                fmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ('00' + o[k]).substring(('' + o[k]).length))
                            }
                        }
                    }
                    return fmt;
                },
                /*显示聚类人数*/
                clusterTextFunction(feature) {
                    var features = feature.get('features');
                    var size = features.length;
                    return size.toString() + "人";
                },
                /*设置聚类图标的半径*/
                radiusFunction(feature) {
                    var features = feature.get('features');
                    var size = features.length;
                    return (20 + size / 2);
                },
                /*
                 绘制区域图形转字符串
                */
                fromArrayGetString(array) {
                    var string = array.join(" ");
                    return string;
                }
            }
        } 

        var vm = new Vue({
            el: '#app',
            mixins:[mixins],
            data() {
                return {
                    rangeMax: 86400000,
                    timeArr: ['', ''],
                    mapHeight: '800px',
                    mapWidth: '800px',
                    endDatas: null,
                    MY_MAP: null,
                    mapData:{
                        ICON_SCALE: 1,
                        TEXT_SCALE: 1
                    },
                    DRAWIng:null,
                    MOVE_LOCATION_X: 0,
                    MOVE_LOCATION_Y: 0,
                    areas: [],
                    pointes: [],
                    tempPointers: [],

                    datalist:[],
                    playParams:{
                        play:true,
                        speed: 1000,
                        totalTime:0,
                        currentTime:0,
                        current:1,
                        max:0
                    }
                }
            },
            created(){
                this.initTime()
                const vm = this
                const startFun = ELEMENT.Slider.components.SliderButton.methods.onDragStart
                

                ELEMENT.Slider.components.SliderButton.methods.onDragStart = function(e) {
                    vm.startDrag()
                    startFun.call(this, e)
                }
               
            },
            mounted: function() {
               
                this.endDatas = JSON.parse(localStorage.getItem('location'))
                this.map2dShow();
                this.getData();

            },
            methods: {
                play_pause(key){
                    this.myInterval(key)
                    this.playParams.play = !key
                },
                startDrag() {
                    console.log(this.playParams)
                     if(this.playParams.timer){
                        clearInterval(this.playParams.timer)
                        this.playParams.timer  = null;
                    }
                },
                sliderInput(e){
                    
                },
                sliderChange(e){
                    this.MY_MAP.removeOneTrack(this.datalist[0].card_id)
                    if(this.playParams.timer){
                        clearInterval(this.playParams.timer)
                        this.playParams.timer  = null;
                    }


                    this.playParams.current = parseInt(e / this.rangeMax * this.playParams.max)

                    this.startHistory()

                },
                
                startHistory(){
                    this.MY_MAP.addTrack(this.datalist[0].card_id, 10000)
                    this.myInterval();
                },
                changeSpeed(v){
                    if(v === 1){
                        this.playParams.speed = 1000
                    }else{
                        this.playParams.speed *= v
                    }
                    
                    if( this.playParams.speed <= 125){
                        this.playParams.speed = 125  
                    }
                    if( this.playParams.speed >= 4000){
                        this.playParams.speed = 4000  
                    }
                    this.myInterval()
                },
                myInterval(key){
                    if(this.playParams.timer){
                        clearInterval(this.playParams.timer)
                        this.playParams.timer  = null;
                    }
                    if(!key){
                        this.historyPlay()
                        this.playParams.timer = setInterval(this.historyPlay,this.playParams.speed)
                    }
                    
                },
                historyPlay(){
                    this.$refs.slider.setPosition(this.playParams.currentTime / this.rangeMax)
                    if(this.playParams.current < this.playParams.max - 1){

                        this.playParams.current++;
                        this.playParams.currentTime = this.playParams.current / this.playParams.max * this.rangeMax
                        this.updateHistory(this.datalist[this.playParams.current])
                    }else{
                        if(this.playParams.timer){
                            clearInterval(this.playParams.timer)
                            this.playParams.timer  = null;
                        }
                    }
                    
                },
                getData(){
                    let range = [this.getlongTime(this.timeArr[0]), this.getlongTime(this.timeArr[1])]
                    for(var i = 0; i <= (range[1] - range[0])/10000; i++){
                        this.datalist.push({
                            card_x: -1 + (0.5 - Math.random()) * 10,
                            card_y: -7 + (0.5 - Math.random()) * 10,
                            icon:'../img/location0.png',
                            card_id: 2,
                            time: i / 100000  * (range[1] - range[0]) + range[0],
                            text:'测试'
                        })
                    }
                    this.playParams.totalTime = range[1] - range[0];
                    this.playParams.max = this.datalist.length;
                    this.playParams.speed = 1000;
                    this.playParams.current = 0
                    this.playParams.currentTime = 0
                    
                    this.showCard(this.datalist[0])
                    this.startHistory()
                },
                showCard({card_id,icon,card_x,card_y,text}){
                    this.MY_MAP.addCardInfo(card_id,icon,card_x,card_y,text,{icon_scale: 0.5});
                }, 
                updateHistory({card_id,card_x,card_y}){

                    this.MY_MAP.setCardCoordinate(card_id,card_x,card_y);
                },
                initTime(){
                    let timeStr = new Date().format('yyyy-mm-dd')
                    this.timeArr = [new Date(timeStr + ' 00:00:00'), new Date(timeStr + ' 23:59:59')]
                },
                formatTooltip(e){
                    let range = [this.getlongTime(this.timeArr[0]), this.getlongTime(this.timeArr[1])]
                    let time  = e / this.rangeMax  * (range[1] - range[0]) + range[0];
                    return new Date(time).format('yyyy-mm-dd hh:mm:ss')
                },
                searchClick(key){
                   //this.range = [this.getlongTime(this.timeArr[0]), this.getlongTime(this.timeArr[1])] ;
                },
                getlongTime(data){
                    if(data){
                        return new Date(data).getTime()
                    }
                    return 0
                },
                clearDrawing() {
                    if (this.DRAWing) {
                        this.MY_MAP.removeInteraction(this.DRAWing);
                    }
                },
                area_ok(){
                    this.$refs.areaForm.validate((valid) => {
                      if (valid) {
                        this.areas.push({
                            pointers: this.tempPointers,
                            datas: {...this.areaForm}
                        });
                        this.dialogVisible = false;
                        this.showAreas()
                      } else {
                        return false;
                      }
                    });
                },
                startDRAWing(DRAWing_type, flag){
                    if(this.DRAWing){
                        this.clearDrawing()
                    }

                    switch (DRAWing_type) {
                        case "circle":
                            this.DRAWing = new HG2DMap.draw.regular_polygon(64); // 实例化一个绘制圆形的方法(64个点组成的圆,可配置)
                            break;
                        case "polygon":
                            this.DRAWing = new HG2DMap.draw.polygon; // 实例化一个绘制多边形的方法
                            break;
                        case "trigonal":
                            this.DRAWing = new HG2DMap.draw.regular_polygon(3); // 实例化一个绘制三边形的方法
                            break;
                        case "rect":
                            this.DRAWing = new HG2DMap.draw.rectangle; // 实例化一个绘制矩形的方法
                            break;
                    }

                    this.MY_MAP.addInteraction(this.DRAWing); // 将绘制圆的方法添加到地图对象中

                    this.DRAWing.on("drawend", e => {
                        var pointers = e.feature.getGeometry().getCoordinates(); // 获取图形坐标点
                        this.tempPointers =  pointers[0];
                        
                        if (DRAWing_type == "polygon") {
                            // 多边形绘制完成后会判断图形是否自相交,使用SDK中的isSelfIntersection()判断
                            if ((pointers[0][2][0] == pointers[0][1][0]) && (pointers[0][2][1] == pointers[0][1][1])) {
                                this.$message.error("图形不能是一条直线！");
                            } else if (!(HG2DMap.draw.isSelfIntersection(pointers[0]))) {
                               this.dialogVisible = true
                            }
                        } else {
                            this.dialogVisible = true 
                        }
                        
                        this.MY_MAP.removeInteraction(this.DRAWing);  // 删除绘制方式
                        this.DRAWing = undefined;
                    });



                },

                getIconScale() {
                    // 得到当前地图的缩放比
                    var zoom = this.MY_MAP.getZoom();
                    // 缩放比最大为47，根据2dSDK可知，改变图标的大小，就是改变参数icon_scale的值(参数icon_scale的默认值是1)
                    this.mapData.ICON_SCALE = 1 - (47 - parseInt(zoom)) * 0.04;// 当缩放比减小1，则icon_scale的值就减小0.06(这个值可以自己根据实际情况设置)；图标图片的大小应该选择缩放比为最大(即47)时最合适的大小
                    this.mapData.TEXT_SCALE = 1 + (parseInt(zoom) - 40) * 0.04;// 同理ICON_SCALE，图标上的字体大小变化
                    if (this.mapData.ICON_SCALE <= 0.1) {
                        this.mapData.ICON_SCALE = 0.1;
                    }
                    if (this.mapData.TEXT_SCALE <= 0.1) {
                        this.mapData.TEXT_SCALE = 0.1;
                    }
                },

                // 地图上画点
                DRAWingPointer(datas) {
                    this.mapData.MOVE_DATA = datas.data;
                    this.mapData.MOVE_IMG = datas.img;
                    this.mapData.MOVE_TEXT = datas.data.name;
                    this.getIconScale();
                    this.MY_MAP.getTarget().style.cursor = "pointer";
                    // 得到鼠标的像素点
                    var pixel = this.MY_MAP.getEventPixel(datas.event);
                    // 得到该像素点的坐标
                    var location_x = this.MY_MAP.getCoordinateFromPixel(pixel)[0].toFixed(2);
                    var location_y = this.MY_MAP.getCoordinateFromPixel(pixel)[1].toFixed(2);
                    if (this.mapData.ICON_SCALE <= 0.1) {
                        this.$message.error("地图缩放比太小，不能新增！");
                        return;
                    }
                    this.MOVE_FEATURE = new HG2DMap.feature.point([location_x, location_y], Object.assign({
                        icon: this.mapData.MOVE_IMG,
                        text: this.mapData.MOVE_TEXT,
                        icon_scale: this.mapData.ICON_SCALE * 1,
                        text_scale: this.mapData.TEXT_SCALE * 1.2
                    },this.mapData.MOVE_DATA.text_color? {
                        text_color:this.mapData.MOVE_DATA.text_color
                    }:null));
                    this.MY_MAP.addFeature(this.MOVE_FEATURE);
                    this.MOVE_LOCATION_X = location_x;
                    this.MOVE_LOCATION_Y = location_y;
                    this.MY_MAP.on("pointermove", this.movePointer);
                    this.MY_MAP.on("click", this.addPointer);
                },
                //  地图上添加点
                addPointer(e) {
                    this.getIconScale();
                    if (this.mapData.ICON_SCALE <= 0.1) {
                        HG_MESSAGE("地图缩放比太小，不能新增");
                        return;
                    }
                    this.MY_MAP.un("pointermove", this.movePointer);
                    this.MY_MAP.removeFeature(this.MOVE_FEATURE);
                    if (e.dragging) {
                        return;
                    }
                    // 得到鼠标点击地图时的像素点
                    var pixel = this.MY_MAP.getEventPixel(e.originalEvent);
                    // 得到该像素点的坐标
                    var location_x = this.MY_MAP.getCoordinateFromPixel(pixel)[0].toFixed(2);
                    var location_y = this.MY_MAP.getCoordinateFromPixel(pixel)[1].toFixed(2);
                    this.pointes.push({
                        x: location_x,
                        y: location_y,
                        datas: this.mapData
                    })

                    this.showPointers()

                   
                },
                // 地图上点随鼠标移动
                movePointer(e) {
                    if (e.dragging) {
                        return;
                    }
                    // 得到鼠标的像素点
                    var pixel = this.MY_MAP.getEventPixel(e.originalEvent);
                    // 得到该像素点的坐标
                    var location_x = this.MY_MAP.getCoordinateFromPixel(pixel)[0].toFixed(2);
                    var location_y = this.MY_MAP.getCoordinateFromPixel(pixel)[1].toFixed(2);
                    this.MOVE_LOCATION_X = location_x;
                    this.MOVE_LOCATION_Y = location_y;
                    this.MOVE_FEATURE.setCoordinates([location_x, location_y]);
                },
                // 取消画操作
                canceDRAWing(e) {
                    if (this.DRAWing) {
                        if (e.which === 27) {
                            if (this.MOVE_FEATURE) {
                                this.MY_MAP.removeFeature(this.MOVE_FEATURE);
                                this.MY_MAP.un("pointermove", this.movePointer);
                                this.MY_MAP.un("click", this.addPointer);
                            }
                            this.MY_MAP.removeInteraction(this.DRAWing);
                            this.MY_MAP.getTarget().style.cursor = "";
                            this.MY_MAP.removeControlMeasure();
                            this.DRAWing = null;
                        }
                    }
                },
                //显示所有区域
                showAreas(){
                    this.MY_MAP.removeAllZone();

                    this.areas.forEach(item => {
                        this.MY_MAP.addZone(
                            item.pointers,
                            item.datas.areaCode,
                            item.datas.areaName,
                            item.datas.color, 
                            {'text_color': item.datas.textColor}
                            )
                    })
                },
                // 显示所有点
                showPointers(){

                    this.MY_MAP.removeAllFeature();
                    this.pointes.forEach(item => {

                        this.MOVE_FEATURE = new HG2DMap.feature.point([item.x, item.y], Object.assign({
                            icon: item.datas.MOVE_IMG,
                            text: item.datas.MOVE_TEXT,
                            icon_scale: item.datas.ICON_SCALE * 1,
                            text_scale: item.datas.TEXT_SCALE * 1.2
                        },item.datas.MOVE_DATA.text_color? {
                            text_color: item.datas.MOVE_DATA.text_color
                        }:null));

                        this.MOVE_FEATURE.data = item.datas.MOVE_DATA
                        this.MY_MAP.addFeature(this.MOVE_FEATURE);
                        this.MY_MAP.un("click", this.addPointer);
                    })
                },

                // 初始化地图
                map2dShow() {

                    document.getElementById('map').innerHTML = ''

                    var extend = [
                        this.endDatas.coordinate_left,
                        this.endDatas.coordinate_down,
                        this.endDatas.coordinate_right,
                        this.endDatas.coordinate_upper
                    ];
                    // 调用mapAutomaticSetting函数返回缩放比，中心视点和地图拖拽比
                    var obj = this.mapAutomaticSetting(
                        this.endDatas.floor_scaling_ratio,
                        this.endDatas.origin_x,
                        this.endDatas.origin_y,
                        this.endDatas.drop_multiple,
                        extend,
                        "map");

                    this.MY_MAP = new HG2DMap.map(this.endDatas.img_url, "map", obj.center, obj.zoom, 'image', extend, {
                        extent: obj.extent,
                        zoom_factor: 1.5,
                        rotation: this.endDatas.rotation
                    });


                    var my_mouse_postion = new HG2DMap.control.mouse_position(); // 调用2d地图SDK中的实例化鼠标坐标工具
                    var my_scale_line = new HG2DMap.control.scale_line(); // 调用2d地图SDK中的实例化比例尺工具
                    var my_drag_rotate = new HG2DMap.draw.drag_rotate(); // 调用2d地图SDK中的地图旋转
                    this.MY_MAP.addInteraction(my_drag_rotate); // 调用2d地图SDK中的给地图添加地图旋转
                    this.MY_MAP.addControl(my_mouse_postion); // 调用2d地图SDK中的给地图添加鼠标坐标工具
                    this.MY_MAP.addControl(my_scale_line); // 调用2d地图SDK中的给地图添加比例尺工具
                },
                
            }
        })
    </script>
</body>

</html>

</html>

</html>

</html>